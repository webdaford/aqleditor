// Xtext grammar for Asterix Query Language "AQL"
// webdaford@fordcochrane.com
//
//grammar edu.uci.ics.asterixdb.AQL with org.eclipse.xtext.common.Terminals
grammar edu.uci.ics.asterixdb.AQL hidden(WS, ML_COMMENT, SL_COMMENT)

generate aqlmodel "http://edu.uci.ics.asterixdb/1.0/AQL"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Statements:
    (decls+=Statement ";")*;

Statement:
    DataverseDeclaration
    | FunctionDeclaration
    | CreateStatement
    | LoadStatement
    | DropStatement
    | WriteStatement
    | SetStatement
    | InsertStatement
    | DeleteStatement
    | UpdateStatement
    | FeedStatement
    | CompactStatement
    | Query
    | RefreshExternalDatasetStatement;

DataverseDeclaration:
    "use" "dataverse" name=Identifier;

CreateStatement returns CreateStatement:
    "create"
    (TypeSpecification
    | NodegroupSpecification
    | DatasetSpecification
    | IndexSpecification
    | DataverseSpecification
    | FunctionSpecification
    | FeedSpecification);

TypeSpecification returns CreateTypeSpecification:
    "type" {CreateTypeSpecification} name=TypeName ifNotExists?=IfNotExists
    "as" typeExpr=TypeExpr;

NodegroupSpecification returns CreateNodegroupSpecification:
    "nodegroup" {CreateNodegroupSpecification} name=Identifier
    ifNotExists?=IfNotExists "on" ncNames+=Identifier
    ("," ncNames+=Identifier)*;

DatasetSpecification:
    ("external" "dataset" {ExternalDatasetSpecification} name=QualifiedName
    "(" typeName=Identifier ")"
    (ifNotExists?=IfNotExists)
    ("using" adapterName=AdapterName properties=Configuration)
    ("on" nodeGroupName=Identifier)?
    ("hints" hints=Properties)?
    ("using" "compaction" "policy" compactionPolicy=CompactionPolicy (compactionPolicyProperties=Configuration)?)?
    | ("internal")? "dataset" {InternalDatasetSpecification} name=QualifiedName
    "(" typeName=Identifier ")"
    ifNotExists?=IfNotExists
    primaryKeyFields=PrimaryKey
    (autogenerated?="autogenerated")?
    ("on" nodeGroupName=Identifier)?
    ("hints" hints=Properties)?
    ("using" "compaction" "policy" compactionPolicy=CompactionPolicy (compactionPolicyProperties=Configuration)?)?
    ("with" "filter" "on" filterField=FilterField)?);

RefreshExternalDatasetStatement:
    "refresh" "external" "dataset" name=QualifiedName;

IndexSpecification:
    "index" {IndexSpecification} name=Identifier
    ifNotExists?=IfNotExists
    "on" nameComponents=QualifiedName
    "(" (cis+=Identifier) ("," cis+=Identifier)* ")" ("type" indexType=IndexType)?;

CompactionPolicy:
    name=Identifier;

FilterField:
    name=Identifier;

IndexType:
    (type="btree"
    | type="rtree"
    | type="keyword"
    | type="ngram" "(" arity=INTEGER_LITERAL ")");

DataverseSpecification returns CreateDataverseSpecification:
    "dataverse" {CreateDataverseSpecification} name=Identifier
    ifNotExists?=IfNotExists
    ("with" "format" format=STRING_LITERAL)?;

FunctionSpecification returns CreateFunctionSpecification:
    "function" {CreateFunctionSpecification} name=FunctionName
    ifNotExists?=IfNotExists
    paramList=ParameterList
    "{"
    functionBodyExpr=Expression
    "}";

FeedSpecification returns CreateFeedSpecification:
    ("feed" {CreateFeedSpecification} name=QualifiedName
    ifNotExists?=IfNotExists
    "using" adaptorName=AdapterName properties=Configuration
    (appliedFunction=ApplyFunction)?);

ParameterList:
    "(" {ParameterList} (varLit+=VARIABLE_LITERAL ("," varLit+=VARIABLE_LITERAL)*)? ")";

IfNotExists:
    ("if not exists")?;

    // Review original line 593
ApplyFunction:
    "apply" "function" name=FunctionName;

GetPolicy:
    "using" "policy" name=Identifier;

FunctionSignature:
    name=FunctionName "@" INTEGER_LITERAL;

PrimaryKey:
    "primary key" primaryKeyFields+=Identifier
    ("," primaryKeyFields+=Identifier)*;

    //	// Needs attention.  See original
DropStatement:
    "drop"
    ("dataset" {DropDatasetStatement} pairId=QualifiedName ifExists?=IfExists
    | "index" {DropIndexStatement} tripleId=DoubleQualifiedName ifExists?=IfExists
    | "nodegroup" {DropNodegroupStatement} id=Identifier ifExists?=IfExists
    | "type" {DropTypeStatement} pairId=TypeName ifExists?=IfExists
    | "dataverse" {DropDataverseStatement} id=Identifier ifExists?=IfExists
    | "function" {DropFunctionStatement} funcSig=FunctionSignature ifExists?=IfExists
    | "feed" {DropFeedStatement} pairId=QualifiedName ifExists?=IfExists);

IfExists:
    ("if exists")?;

InsertStatement:
    "insert into dataset" name=QualifiedName query=Query;

DeleteStatement:
    "delete" name=Variable
    "from" "dataset" nameComponents=QualifiedName
    ("where" condition=Expression)?;

UpdateStatement:
    "update" name=Variable "in" target=Expression
    "where" condition=Expression
    "(" (ucs+=UpdateClause
    ("," ucs+=UpdateClause)*) ")";

UpdateClause:
    "set" target=Expression ":=" value=Expression
    | is=InsertStatement
    | ds=DeleteStatement
    | us=UpdateStatement
    | "if (" condition=Expression ")"
    "then" ifbranch=UpdateClause
    -> "else" elsebranch=UpdateClause;

SetStatement:
    "set" name=Identifier pv=STRING_LITERAL;

WriteStatement:
    "write output to" name=Identifier ":" fileName=STRING_LITERAL
    ("using" writerClass=STRING_LITERAL)?;

LoadStatement:
    "load dataset" name=QualifiedName
    "using" adapterName=AdapterName properties=Configuration
    (alreadySorted?="pre-sorted")?;

AdapterName:
    name=Identifier;

CompactStatement:
    "compact dataset" nameComponents=QualifiedName;

FeedStatement:
    ("connect feed" {ConnectFeedStatement} feedNameComponents=QualifiedName "to dataset"
    datasetNameComponents=QualifiedName
    (policy=GetPolicy)?
    | "disconnect feed" {DisconnectFeedStatement} feedNameComponents=QualifiedName "from" "dataset"
    datasetNameComponents=QualifiedName);

Configuration:
    "(" {Configuration} (keyValuePair+=KeyValuePair
    ("," keyValuePair+=KeyValuePair)*)? ")";

KeyValuePair:
    "(" key=STRING_LITERAL "=" value=STRING_LITERAL ")";

Properties:
    {Properties}
    ("(" property+=Property
    ("," property+=Property)* ")")?;

Property:
    name=Identifier "=" (value=STRING_LITERAL | value=INTEGER_LITERAL);

TypeExpr:
    (RecordTypeDef
    | TypeReference
    | OrderedListTypeDef
    | UnorderedListTypeDef);

RecordTypeDef:
    {RecordTypeDef}
    (type="closed" | type="open")?
    "{"
    (rf+=RecordField ("," rf+=RecordField)*)?
    "}";

RecordField:
    name=Identifier
    ":" type=TypeExpr (nullable?="?")?;

TypeReference:
    name=Identifier;

OrderedListTypeDef:
    "["
    (type=TypeExpr)
    "]";

UnorderedListTypeDef:
    "{{"
    (type=TypeExpr)
    "}}";

FunctionName:
    => first=Identifier ("." second=Identifier
    ("#" third=Identifier)? | "#" second=Identifier)?;

TypeName:
    name=QualifiedName;

Identifier:
    name=IDENTIFIER_LITERAL | name=STRING_LITERAL;

QualifiedName:
    first=Identifier ("." second=Identifier)?;

DoubleQualifiedName:
    first=Identifier "." second=Identifier ("." third=Identifier)?;

FunctionDeclaration:
    "declare function" name=Identifier
    paramList=ParameterList
    "{" funcBody=Expression "}";

Query:
    expr=Expression;

Expression:
    (OperatorExpr
    | IfThenElse
    | FLWOGR
    | QuantifiedExpression);

OperatorExpr returns Expression:
    AndExpr ({OperatorExpr.left=current} "or"
    right=AndExpr)*;

AndExpr returns Expression:
    RelExpr ({AndExpr.left=current} "and" right=RelExpr)*;

RelExpr returns Expression:
    AddExpr
    -> ({RelExpr.left=current} op=("<" | ">" | "<=" | ">=" | "=" | "!=" | "~=") right=AddExpr)?;

AddExpr returns Expression:
    MultExpr ({AddExpr.left=current} -> op=("+" | "-") right=MultExpr)*;

MultExpr returns Expression:
    UnionExpr ({MultExpr.left=current} op=("*" | "/" | "%" | "^" | "idiv") right=UnionExpr)*;

UnionExpr returns Expression:
    UnaryExpr ({UnionExpr.left=current} "union" right=UnaryExpr)*;

    // Original
//UnaryExpr returns Expression:
//	(-> ("+" | "-"))? expr=ValueExpr;
UnaryExpr returns Expression:
    ValueExpr | {UnaryExpr} -> op=("+" | "-") expr=UnaryExpr;

    // Original
//ValueExpr returns Expression:
//	expr=PrimaryExpr (fa+=Field | fa+=Index)*;
ValueExpr returns Expression:
    PrimaryExpr ({ValueExpr.expr=current} fa+=Field | fa+=Index)*;

Field:
    "." ident=Identifier;

Index:
    => "[" {Index} (expr=Expression | "?" // ANY 
) "]";

PrimaryExpr returns Expression:
    (FunctionCallExpr
    | Literal
    | DatasetAccessExpression
    | VariableRef
    | ListConstructor
    | RecordConstructor
    | ParenthesizedExpression);

Literal returns Expression:
    {StringLiteral} lit=STRING_LITERAL
    | {IntegerLiteral} lit=INTEGER_LITERAL
    | {FloatLiteral} lit=FLOAT_LITERAL
    | {DoubleLiteral} lit=DOUBLE_LITERAL
    | {NullLiteral} lit="null"
    | {BooleanLiteral} (lit="true" | lit="false");

VariableRef returns Expression:
    {Expression} VARIABLE_LITERAL;

Variable:
    VARIABLE_LITERAL;

ListConstructor:
    (OrderedListConstructor
    | UnorderedListConstructor);

OrderedListConstructor:
    "[" {OrderedListConstructor}
    (exprList+=Expression
    ("," exprList+=Expression)*)?
    "]";

UnorderedListConstructor:
    "{{" {UnorderedListConstructor} (exprList+=Expression
    ("," exprList+=Expression)*)? "}}";

RecordConstructor:
    "{" {RecordConstructor}
    (fbList+=FieldBinding ("," fbList+=FieldBinding)*)?
    "}";

FieldBinding:
    left=Expression ":" right=Expression;

FunctionCallExpr returns Expression:
    funcName=FunctionName
    "(" (argList+=Expression
    ("," argList+=Expression)*)? ")";

DatasetAccessExpression returns Expression:
    "dataset"
    ((arg1=Identifier (=> "." arg2=Identifier)?)
    | ("(" nameArg=Expression ")"));

ParenthesizedExpression returns Expression:
    "(" Expression ")";

IfThenElse returns Expression:
    "if (" condExpr=Expression ") then" thenExpr=Expression "else" elseExpr=Expression;

FLWOGR returns Expression:
    {FLWOGR}
    (clauseList+=ForClause | clauseList+=LetClause)
    (clauseList+=Clause)* "return" returnExpr=Expression;

Clause:
    (ForClause
    | LetClause
    | WhereClause
    | OrderbyClause
    | GroupClause
    | LimitClause
    | DistinctClause);

ForClause:
    "for" varExp=Variable ("at" varPos=Variable)? "in" (inExp=Expression);

LetClause:
    "let" varExp=Variable ":=" beExp=Expression;

WhereClause:
    "where" whereExpr=Expression;

OrderbyClause:
    ("order by" orderbyList+=Expression
    (("asc") | ("desc"))?
    ("," orderbyList+=Expression
    (("asc") | ("desc"))?)*);

GroupClause:
    "group by" (var+=Variable ":=")?
    expr+=Expression
    ("," (var+=Variable ":=")? expr+=Expression)*
    ("decor" decorVar+=Variable ":=" decorExpr+=Expression
    ("," "decor" decorVar+=Variable ":=" decorExpr+=Expression)*)?
    "with" withVarList+=VariableRef ("," withVarList+=VariableRef)*;

LimitClause:
    "limit" limitExpr=Expression
    ("offset" offSetExpr=Expression)?;

DistinctClause:
    "distinct by" exprs+=Expression
    ("," exprs+=Expression)*;

    // Refine see line 2170 in original
QuantifiedExpression returns Expression:
    (("some") | ("every"))
    var+=Variable "in" inExpr+=Expression
    ("," var+=Variable "in" inExpr+=Expression)*
    "satisfies" satisfiesExpr=Expression;

    //--------------  Terminals ---------------
terminal fragment DIGIT:
    ('0'..'9');

terminal fragment DIGITS:
    DIGIT+;

terminal DOUBLE_LITERAL:
//    DIGITS | DIGITS ("." DIGITS)? | "." DIGITS;
    DIGITS "." DIGITS? | "." DIGITS;

terminal FLOAT_LITERAL:
//    DIGITS ("f" | "F") | DIGITS ("." DIGITS ("f" | "F"))? | "." DIGITS ("f" | "F");
    DIGITS "." DIGITS? ("f" | "F") | "." DIGITS ("f" | "F");

terminal INTEGER_LITERAL:
    DIGITS;

terminal STRING_LITERAL:
    ("\"" (ESCAPE_QUOT | !("\""))* "\"") | ("\'" (ESCAPE_APOS | !("\'"))* "\'");

terminal fragment ESCAPE_QUOT:
    "\\\"";

terminal fragment ESCAPE_APOS:
    "\\\'";

terminal IDENTIFIER_LITERAL:
    LETTER (LETTER | DIGIT | SPECIALCHARS)*;

terminal VARIABLE_LITERAL:
    "$" IDENTIFIER_LITERAL;

terminal fragment LETTER:
    ("A".."Z") | ("a".."z");

terminal fragment SPECIALCHARS:
    "$" | "_" | "-";

terminal ML_COMMENT:
    '/*'->'*/';

terminal SL_COMMENT:
    '//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
    (' ' | '\t' | '\r' | '\n')+;