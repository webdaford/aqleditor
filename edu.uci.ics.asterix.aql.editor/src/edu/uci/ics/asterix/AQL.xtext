
// Copyright 2014 by Dell Inc. and others.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// you may obtain a copy of the License from
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Xtext grammar for Asterix Query Language "AQL"
// webdaford@fordcochrane.com
//grammar edu.uci.ics.asterixdb.AQL with org.eclipse.xtext.common.Terminals
grammar edu.uci.ics.asterixdb.AQL hidden(WS, ML_COMMENT, SL_COMMENT)

generate aqlmodel "http://edu.uci.ics.asterixdb/1.0/AQL"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Statements:
    (decls+=Statement (";")?)*;

Statement:
    DataverseDeclaration
    | FunctionDeclaration
    | CreateStatement
    | LoadStatement
    | DropStatement
    | WriteStatement
    | SetStatement
    | InsertStatement
    | DeleteStatement
    | UpdateStatement
    | FeedStatement
    | CompactStatement
    | Query
    | RefreshExternalDatasetStatement;

DataverseDeclaration:
    "use" "dataverse" dataverse=Identifier;

CreateStatement returns CreateStatement:
    "create"
    (TypeSpecification
    | NodegroupSpecification
    | DatasetSpecification
    | IndexSpecification
    | DataverseSpecification
    | FunctionSpecification
    | FeedSpecification);

TypeSpecification returns CreateTypeSpecification:
    "type" {CreateTypeSpecification} name=TypeName ifNotExists?=IfNotExists
    "as" typeExpr=TypeExpr;

NodegroupSpecification returns CreateNodegroupSpecification:
    "nodegroup" {CreateNodegroupSpecification} name=Identifier
    ifNotExists?=IfNotExists "on" ncNames+=Identifier
    ("," ncNames+=Identifier)*;

DatasetSpecification:
    ("external" "dataset" {ExternalDatasetSpecification} name=QualifiedName
    "(" typeName=Identifier ")"
    (ifNotExists?=IfNotExists)
    ("using" adapterName=AdapterName properties=Configuration)
    ("on" nodeGroupName=Identifier)?
    ("hints" hints=Properties)?
    ("using" "compaction" "policy" compactionPolicy=CompactionPolicy (=> compactionPolicyProperties=Configuration)?)?
    | ("internal")? "dataset" {InternalDatasetSpecification} name=QualifiedName
    "(" typeName=Identifier ")"
    ifNotExists?=IfNotExists
    primaryKeyFields=PrimaryKey
    (autogenerated?="autogenerated")?
    ("on" nodeGroupName=Identifier)?
    ("hints" hints=Properties)?
    ("using" "compaction" "policy" compactionPolicy=CompactionPolicy (=> compactionPolicyProperties=Configuration)?)?
    ("with" "filter" "on" filterField=FilterField)?);

RefreshExternalDatasetStatement:
    "refresh" "external" "dataset" datasetName=QualifiedName;

IndexSpecification:
    "index" {IndexSpecification} name=Identifier
    ifNotExists?=IfNotExists
    "on" nameComponents=QualifiedName
    "(" (cis+=Identifier) ("," cis+=Identifier)* ")" ("type" indexType=IndexType)?;

CompactionPolicy:
    policy=Identifier;

FilterField:
    field=Identifier;

IndexType:
    (type="btree"
    | type="rtree"
    | type="keyword"
    | type="ngram" "(" arity=INTEGER_LITERAL ")");

DataverseSpecification returns CreateDataverseSpecification:
    "dataverse" {CreateDataverseSpecification} name=Identifier
    ifNotExists?=IfNotExists
    ("with" "format" format=STRING_LITERAL)?;

FunctionSpecification returns CreateFunctionSpecification:
    "function" {CreateFunctionSpecification} name=FunctionName
    ifNotExists?=IfNotExists
    paramList=ParameterList
    "{"
    functionBodyExpr=Expression
    "}";

FeedSpecification returns CreateFeedSpecification:
    ("feed" {CreateFeedSpecification} name=QualifiedName
    ifNotExists?=IfNotExists
    "using" adaptorName=AdapterName properties=Configuration
    (appliedFunction=ApplyFunction)?);

ParameterList:
    "(" {ParameterList} (varLit+=VARIABLE_LITERAL ("," varLit+=VARIABLE_LITERAL)*)? ")";

IfNotExists:
    ("if" "not" "exists")?;

    // Review original line 593
ApplyFunction:
    "apply" "function" functionName=FunctionName;

GetPolicy:
    "using" "policy" policyName=Identifier;

FunctionSignature:
    functionName=FunctionName "@" INTEGER_LITERAL;

PrimaryKey:
    "primary" "key" primaryKeyFields+=Identifier
    ("," primaryKeyFields+=Identifier)*;

    //	// Needs attention.  See original
DropStatement:
    "drop"
    ("dataset" {DropDatasetStatement} pairId=QualifiedName ifExists?=IfExists
    | "index" {DropIndexStatement} tripleId=DoubleQualifiedName ifExists?=IfExists
    | "nodegroup" {DropNodegroupStatement} id=Identifier ifExists?=IfExists
    | "type" {DropTypeStatement} pairId=TypeName ifExists?=IfExists
    | "dataverse" {DropDataverseStatement} id=Identifier ifExists?=IfExists
    | "function" {DropFunctionStatement} funcSig=FunctionSignature ifExists?=IfExists
    | "feed" {DropFeedStatement} pairId=QualifiedName ifExists?=IfExists);

IfExists:
    ("if" "exists")?;

InsertStatement:
    "insert" "into" "dataset" datasetName=QualifiedName query=Query;

DeleteStatement:
    "delete" variableName=Variable
    "from" "dataset" nameComponents=QualifiedName
    ("where" condition=Expression)?;

UpdateStatement:
    "update" variableName=Variable "in" target=Expression
    "where" condition=Expression
    "(" (ucs+=UpdateClause
    ("," ucs+=UpdateClause)*) ")";

UpdateClause:
    "set" target=Expression ":=" value=Expression
    | is=InsertStatement
    | ds=DeleteStatement
    | us=UpdateStatement
    | "if" "(" condition=Expression ")"
    "then" ifbranch=UpdateClause
    "else" elsebranch=UpdateClause;

SetStatement:
    "set" variableName=Identifier pv=STRING_LITERAL;

WriteStatement:
    "write" "output" "to" outputName=Identifier ":" fileName=STRING_LITERAL
    ("using" writerClass=STRING_LITERAL)?;

LoadStatement:
    "load" "dataset" inputName=QualifiedName
    "using" adapterName=AdapterName properties=Configuration
    (alreadySorted?="pre-sorted")?;

AdapterName:
    adapterName=Identifier;

CompactStatement:
    "compact" "dataset" nameComponents=QualifiedName;

FeedStatement:
    ("connect" "feed" {ConnectFeedStatement} feedNameComponents=QualifiedName "to" "dataset"
    datasetNameComponents=QualifiedName
    (policy=GetPolicy)?
    | "disconnect" "feed" {DisconnectFeedStatement} feedNameComponents=QualifiedName "from" "dataset"
    datasetNameComponents=QualifiedName);

Configuration:
    "(" {Configuration} (keyValuePair+=KeyValuePair ("," keyValuePair+=KeyValuePair)*)? ")";

KeyValuePair:
    "(" key=STRING_LITERAL "=" value=STRING_LITERAL ")";

Properties:
	{Properties} (=> "(" property+=Property ("," property+=Property)* ")")?;

Property:
    name=Identifier "=" (value=STRING_LITERAL | value=INTEGER_LITERAL);

TypeExpr:
    (RecordTypeDef
    | TypeReference
    | OrderedListTypeDef
    | UnorderedListTypeDef);

RecordTypeDef:
    {RecordTypeDef}
    (type="closed" | type="open")?
    "{"
    (rf+=RecordField ("," rf+=RecordField)*)?
    "}";

RecordField:
    name=Identifier
    ":" type=TypeExpr (nullable?="?")?;

TypeReference:
    type=Identifier;

OrderedListTypeDef:
    "["
    (type=TypeExpr)
    "]";

UnorderedListTypeDef:
    "{{"
    (type=TypeExpr)
    "}}";

FunctionName:
    => first=Identifier ("." second=Identifier
    ("#" third=Identifier)? | "#" second=Identifier)?;

TypeName:
    typeName=QualifiedName;

Identifier:
    identifierName=IDENTIFIER_LITERAL | identifierName=STRING_LITERAL;

QualifiedName:
    first=Identifier ("." second=Identifier)?;

DoubleQualifiedName:
    first=Identifier "." second=Identifier ("." third=Identifier)?;

FunctionDeclaration:
    "declare" "function" name=Identifier
    paramList=ParameterList
    "{" funcBody=Expression "}";

Query:
    expr=Expression;

Expression:
    (OperatorExpr
    | IfThenElse
    | FLWOGR
    | QuantifiedExpression);

OperatorExpr returns Expression:
    AndExpr ({OperatorExpr.left=current} "or"
    right=AndExpr)*;

AndExpr returns Expression:
    RelExpr ({AndExpr.left=current} "and" right=RelExpr)*;

RelExpr returns Expression:
    AddExpr
    ({RelExpr.left=current} op=("<" | ">" | "<=" | ">=" | "=" | "!=" | "~=") right=AddExpr)?;

AddExpr returns Expression:
    MultExpr ({AddExpr.left=current} op=("+" | "-") right=MultExpr)*;

MultExpr returns Expression:
    UnionExpr ({MultExpr.left=current} op=("*" | "/" | "%" | "^" | "idiv") right=UnionExpr)*;

UnionExpr returns Expression:
    UnaryExpr ({UnionExpr.left=current} "union" right=UnaryExpr)*;

// see http://dslmeinte.wordpress.com/2011/03/21/pre-and-postfix-operators-in-xtext/
    // Original
//UnaryExpr returns Expression:
//	(-> ("+" | "-"))? expr=ValueExpr;
UnaryExpr returns Expression:
    ValueExpr | {UnaryExpr} => op=("f" | "p") expr=ValueExpr;
	
	
    // Original
//ValueExpr returns Expression:
//	expr=PrimaryExpr (fa+=Field | fa+=Index)*;
ValueExpr returns Expression:
    PrimaryExpr ({ValueExpr.expr=current} fa+=Field | fa+=Index)*;

Field:
    "." ident=Identifier;

Index:
    => "[" {Index} (expr=Expression | "?" // ANY 
) "]";

PrimaryExpr returns Expression:
    (FunctionCallExpr
    | Literal
    | DatasetAccessExpression
    | VariableRef
    | ListConstructor
    | RecordConstructor
    | ParenthesizedExpression);

Literal returns Expression:
    {StringLiteral} lit=STRING_LITERAL
    | {IntegerLiteral} lit=INTEGER_LITERAL
    | {FloatLiteral} lit=FLOAT_LITERAL
    | {DoubleLiteral} lit=DOUBLE_LITERAL
    | {NullLiteral} lit="null"
    | {BooleanLiteral} (lit="true" | lit="false");

VariableRef returns Expression:
    {VariableRefExpression} variable=VARIABLE_LITERAL;

Variable:
    lit=VARIABLE_LITERAL;

ListConstructor:
    (OrderedListConstructor
    | UnorderedListConstructor);

OrderedListConstructor:
    "[" {OrderedListConstructor}
    (exprList+=Expression
    ("," exprList+=Expression)*)?
    "]";

UnorderedListConstructor:
    "{{" {UnorderedListConstructor} (exprList+=Expression
    ("," exprList+=Expression)*)? "}}";

RecordConstructor:
    "{" {RecordConstructor}
    (fbList+=FieldBinding ("," fbList+=FieldBinding)*)?
    "}";

FieldBinding:
    left=Expression ":" right=Expression;

FunctionCallExpr returns Expression:
    funcName=FunctionName
    "(" (argList+=Expression
    ("," argList+=Expression)*)? ")";

DatasetAccessExpression returns Expression:
    "dataset"
    ((arg1=Identifier (=> "." arg2=Identifier)?)
    | ("(" nameArg=Expression ")"));

ParenthesizedExpression returns Expression:
    "(" Expression ")";

IfThenElse returns Expression:
    "if" "(" condExpr=Expression ")" "then" thenExpr=Expression "else" elseExpr=Expression;

FLWOGR returns Expression:
    {FLWOGR}
    (clauseList+=ForClause | clauseList+=LetClause)
    (clauseList+=Clause)* "return" returnExpr=Expression;

Clause:
    (ForClause
    | LetClause
    | WhereClause
    | OrderbyClause
    | GroupClause
    | LimitClause
    | DistinctClause);

ForClause:
    "for" varExp=Variable ("at" varPos=Variable)? "in" (inExp=Expression);

LetClause:
    "let" varExp=Variable ":=" beExp=Expression;

WhereClause:
    "where" whereExpr=Expression;

OrderbyClause:
    ("order" "by" orderbyList+=Expression
    (("asc") | ("desc"))?
    ("," orderbyList+=Expression
    (("asc") | ("desc"))?)*);

GroupClause:
    "group" "by" (var+=Variable ":=")?
    expr+=Expression
    ("," (var+=Variable ":=")? expr+=Expression)*
    ("decor" decorVar+=Variable ":=" decorExpr+=Expression
    ("," "decor" decorVar+=Variable ":=" decorExpr+=Expression)*)?
    "with" withVarList+=VariableRef ("," withVarList+=VariableRef)*;

LimitClause:
    "limit" limitExpr=Expression
    ("offset" offSetExpr=Expression)?;

DistinctClause:
    "distinct" "by" exprs+=Expression
    ("," exprs+=Expression)*;

    // Refine see line 2170 in original
QuantifiedExpression returns Expression:
    (("some") | ("every"))
    var+=Variable "in" inExpr+=Expression
    ("," var+=Variable "in" inExpr+=Expression)*
    "satisfies" satisfiesExpr=Expression;

    //--------------  Terminals ---------------
terminal fragment DIGIT:
    ('0'..'9');

terminal fragment DIGITS:
    DIGIT+;

terminal DOUBLE_LITERAL:
//    DIGITS | DIGITS ("." DIGITS)? | "." DIGITS;
    DIGITS "." DIGITS? | "." DIGITS;

terminal FLOAT_LITERAL:
//    DIGITS ("f" | "F") | DIGITS ("." DIGITS ("f" | "F"))? | "." DIGITS ("f" | "F");
    DIGITS "." DIGITS? ("f" | "F") | "." DIGITS ("f" | "F");

terminal INTEGER_LITERAL:
    DIGITS;

terminal STRING_LITERAL:
    ("\"" (ESCAPE_QUOT | !("\""))* "\"") | ("\'" (ESCAPE_APOS | !("\'"))* "\'");

terminal fragment ESCAPE_QUOT:
    "\\\"";

terminal fragment ESCAPE_APOS:
    "\\\'";

terminal IDENTIFIER_LITERAL:
    LETTER (LETTER | DIGIT | SPECIALCHARS)*;

terminal VARIABLE_LITERAL:
    "$" IDENTIFIER_LITERAL;

terminal fragment LETTER:
    ("A".."Z") | ("a".."z");

terminal fragment SPECIALCHARS:
    "$" | "_" | "-";

terminal ML_COMMENT:
    '/*'->'*/';

terminal SL_COMMENT:
    '//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
    (' ' | '\t' | '\r' | '\n')+;